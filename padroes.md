# Padrões de Projeto Adotados

| Padrão de Projeto | Descrição | Classes Envolvidas |
| :--- | :--- | :--- |
| **Proxy** | Um padrão estrutural que fornece um substituto ou placeholder para outro objeto controlar o acesso a ele. No projeto, ele é usado para adicionar funcionalidades transversais (logging e medição de tempo) às operações do repositório de feedback (listarPorUsuario, obter, criar, excluir e modificar) sem modificar a implementação real. | **FeedbackRepositorioAplicacao:** Define o contrato comum para FeedbackRepositorioProxy (Proxy) e FeedbackRepositorioReal (RealSubject)</br>`aplicacao/src/main/java/Up/Power/aplicacao/feedback/FeedbackRepositorioAplicacao.java` </br></br>**FeedbackRepositorioReal:** Implementação concreta que executa as operações reais `aplicacao/src/main/java/Up/Power/aplicacao/feedback/FeedbackRepositorioReal.java`</br></br>**FeedbackRepositorioProxy:** Proxy que intercepta chamadas e adiciona funcionalidades`aplicacao/src/main/java/Up/Power/aplicacao/feedback/FeedbackRepositorioProxy.java`</br></br>**FeedbackServicoAplicacao:** Usa a interface FeedbackRepositorioAplicacao sem saber se está usando Proxy ou RealSubject `aplicacao/src/main/java/Up/Power/aplicacao/feedback/FeedbackServicoAplicacao.java`|
| **Template Method** | Um padrão comportamental que define o esqueleto de um algoritmo na classe base, permitindo que subclasses implementem os passos específicos sem alterar a estrutura geral. No contexto de Rivalidade, ele garante que todas as operações (enviar convite, aceitar, recusar, finalizar e cancelar) seguem o mesmo fluxo: validação → execução da operação → conversão para resumo. A classe template define métodos específicos para cada tipo de operação (`executarEnviarConvite`, `executarAceitar`, etc.), cada um seguindo o mesmo padrão de fluxo. As subclasses implementam apenas os métodos de execução específicos de cada operação, recebendo parâmetros diretos. | **OperacaoRivalidadeTemplate:** Classe abstrata que define os templates com métodos específicos para cada operação (executarEnviarConvite, executarAceitar, executarRecusar, executarFinalizar, executarCancelar), cada um contendo o fluxo fixo e ganchos de validação</br>`aplicacao/src/main/java/Up/Power/aplicacao/rivalidade/template/OperacaoRivalidadeTemplate.java`</br></br>**EnviarConviteOperacao:** Implementação concreta que sobrescreve `executarOperacaoEnviarConvite(int perfil1Id, int perfil2Id, int exercicioId)` para enviar um convite de rivalidade `aplicacao/src/main/java/Up/Power/aplicacao/rivalidade/operacoes/EnviarConviteOperacao.java`</br></br>**AceitarRivalidadeOperacao:** Implementação concreta que sobrescreve `executarOperacaoAceitar(int rivalidadeId, int usuarioId)` para aceitar um convite `aplicacao/src/main/java/Up/Power/aplicacao/rivalidade/operacoes/AceitarRivalidadeOperacao.java`</br></br>**RecusarRivalidadeOperacao:** Implementação concreta que sobrescreve `executarOperacaoRecusar(int rivalidadeId, int usuarioId)` para recusar um convite `aplicacao/src/main/java/Up/Power/aplicacao/rivalidade/operacoes/RecusarRivalidadeOperacao.java`</br></br>**FinalizarRivalidadeOperacao:** Implementação concreta que sobrescreve `executarOperacaoFinalizar(int rivalidadeId, int usuarioId)` para finalizar uma rivalidade `aplicacao/src/main/java/Up/Power/aplicacao/rivalidade/operacoes/FinalizarRivalidadeOperacao.java`</br></br>**CancelarRivalidadeOperacao:** Implementação concreta que sobrescreve `executarOperacaoCancelar(int rivalidadeId, int usuarioId)` para cancelar uma rivalidade `aplicacao/src/main/java/Up/Power/aplicacao/rivalidade/operacoes/CancelarRivalidadeOperacao.java`</br></br>**RivalidadeServicoAplicacao:** Serviço que orquestra as operações, recebendo parâmetros diretos e delegando para as operações específicas `aplicacao/src/main/java/Up/Power/aplicacao/rivalidade/RivalidadeServicoAplicacao.java`|
| **Decorator** | Um padrão estrutural que permite adicionar responsabilidades a um objeto dinamicamente sem alterar sua estrutura original. No caso do Plano Nutricional, ele é usado para montar uma cadeia de processamento onde cada decorator adiciona um comportamento extra ao serviço real (RealSubject). A criação e modificação do plano passam por etapas sequenciais: cálculo de calorias → ajustes conforme objetivo → registro de logs. | **CriarPlanoNutricionalCommand:** Representa os dados necessários para criar um plano </br>`aplicacao/src/main/java/Up/Power/aplicacao/planoNutricional/commands/CriarPlanoNutricionalCommand.java`</br></br>**ModificarPlanoNutricionalCommand:** Dados enviados para atualizar um plano </br>`aplicacao/src/main/java/Up/Power/aplicacao/planoNutricional/commands/ModificarPlanoNutricionalCommand.java`</br></br>**PlanoNutricionalApplicationService:** Interface base para o serviço e todos os decorators </br>`aplicacao/src/main/java/Up/Power/aplicacao/planoNutricional/service/PlanoNutricionalApplicationService.java`</br></br>**PlanoNutricionalDecorator:** Classe abstrata que encapsula um serviço e adiciona comportamentos antes/depois da chamada real </br>`aplicacao/src/main/java/Up/Power/aplicacao/planoNutricional/service/decorators/PlanoNutricionalDecorator.java`</br></br>**CalculoCaloriasDecorator:** Calcula calorias totais automaticamente no plano antes de salvar </br>`aplicacao/src/main/java/Up/Power/aplicacao/planoNutricional/service/decorators/CalculoCaloriasDecorator.java`</br></br>**CicloObjetivoDecorator:** Ajusta metas e calorias conforme o objetivo (Cutting / Bulking) </br>`aplicacao/src/main/java/Up/Power/aplicacao/planoNutricional/service/decorators/CicloObjetivoDecorator.java`</br></br>**RegistroInfoDecorator:** Registra logs detalhados das operações </br>`aplicacao/src/main/java/Up/Power/aplicacao/planoNutricional/service/decorators/RegistroInfoDecorator.java`</br></br>**BasePlanoNutricionalService:** Implementação real (RealSubject) usada pelos decorators </br>`aplicacao/src/main/java/Up/Power/aplicacao/planoNutricional/service/BasePlanoNutricionalService.java`</br></br>**PlanoNutricionalConfig:** Monta a cadeia Decorator (Base → CalculoCalorias → CicloObjetivo → RegistroInfo) </br>`aplicacao/src/main/java/Up/Power/aplicacao/planoNutricional/service/PlanoNutricionalConfig.java` |
| Observer | Um padrão comportamental que define uma relação um-para-muitos, onde um objeto central (Subject) notifica automaticamente uma lista de objetos (Observers) sempre que um evento relevante ocorre. No sistema, ele permite que a lógica de conquistas reaja a eventos da aplicação (como treino concluído ou atributos atualizados) sem criar acoplamento entre serviços. O fluxo é: um evento acontece → o Subject notifica todos os Observers → cada Observer decide como reagir (avaliar conquistas, atualizar perfil etc.). | ConquistaObserver: Interface comum que todos os observers devem implementar. É chamada automaticamente quando um evento ocorre. </br>`aplicacao/src/main/java/Up/Power/aplicacao/conquista/ConquistaObserver.java`</br></br>ConquistaServicoAplicacao (Subject): Mantém a lista de observadores, injeta todos via Spring e notifica todos quando um evento ocorre. Contém o método notifyObservers. </br>`aplicacao/src/main/java/Up/Power/aplicacao/conquista/ConquistaServicoAplicacao.java`</br></br>ConquistaAvaliadorAplicacao (Concrete Observer): Recebe eventos do Subject, interpreta o tipo (ex.: "TREINO_CONCLUIDO"), avalia conquistas e atualiza o perfil do usuário.</br>`aplicacao/src/main/java/Up/Power/aplicacao/conquista/ConquistaAvaliadorAplicacao.java`</br></br>TreinoConcluidoEvent / AtributosAtualizadosEvent: DTOs usados como eventData para transportar as informações necessárias a cada evento. </br>`aplicacao/src/main/java/Up/Power/aplicacao/eventos/`</br></br>AvaliadorConquistaService: Serviço de domínio responsável por avaliar regras de conquista a partir dos dados enviados pelo Observer.</br>`dominio/src/main/java/Up/Power/conquista/AvaliadorConquistaService.java` |
| **Strategy** | Um padrão comportamental que define uma família de algoritmos, encapsula cada um deles e os torna intercambiáveis. No contexto de Plano de Treino, ele permite que diferentes estratégias de validação sejam aplicadas aos treinos sem modificar o código cliente. O Spring gerencia a injeção da estratégia através de injeção de dependência, permitindo que o sistema use validações básicas ou completas conforme necessário. O fluxo é: o serviço recebe um treino → delega a validação para a estratégia configurada → a estratégia valida conforme suas regras específicas (básica: apenas exercício e tipo; completa: todos os parâmetros com validações específicas por tipo de treino como Peso vs Cardio). | **ValidacaoTreinoStrategy:** Interface que define o contrato comum para todas as estratégias de validação, com métodos `validar(Treino)` e `getMensagemErro()`</br>`aplicacao/src/main/java/Up/Power/aplicacao/planoTreino/ValidacaoTreinoStrategy.java`</br></br>**ValidacaoTreinoBasicaStrategy:** Implementação concreta que valida apenas se o treino possui exercício e tipo definidos</br>`aplicacao/src/main/java/Up/Power/aplicacao/planoTreino/ValidacaoTreinoBasicaStrategy.java`</br></br>**ValidacaoTreinoCompletaStrategy:** Implementação concreta (marcada com @Primary) que valida todos os parâmetros do treino, incluindo séries, repetições e carga, com validações específicas por tipo (Peso vs Cardio)</br>`aplicacao/src/main/java/Up/Power/aplicacao/planoTreino/ValidacaoTreinoCompletaStrategy.java`</br></br>**PlanoTreinoServicoAplicacao (Context):** Serviço que utiliza a estratégia injetada via Spring para validar treinos nos métodos `adicionarTreino` e `atualizarTreino`, sem conhecer qual estratégia específica está sendo usada</br>`aplicacao/src/main/java/Up/Power/aplicacao/planoTreino/PlanoTreinoServicoAplicacao.java` |
